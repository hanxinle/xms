// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xmsg_com.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_xmsg_5fcom_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_xmsg_5fcom_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "xmsg_type.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_xmsg_5fcom_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_xmsg_5fcom_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_xmsg_5fcom_2eproto;
namespace xmsg {
class XAddLogReq;
class XAddLogReqDefaultTypeInternal;
extern XAddLogReqDefaultTypeInternal _XAddLogReq_default_instance_;
class XAddUserReq;
class XAddUserReqDefaultTypeInternal;
extern XAddUserReqDefaultTypeInternal _XAddUserReq_default_instance_;
class XAuthConfig;
class XAuthConfigDefaultTypeInternal;
extern XAuthConfigDefaultTypeInternal _XAuthConfig_default_instance_;
class XChangePasswordReq;
class XChangePasswordReqDefaultTypeInternal;
extern XChangePasswordReqDefaultTypeInternal _XChangePasswordReq_default_instance_;
class XConfig;
class XConfigDefaultTypeInternal;
extern XConfigDefaultTypeInternal _XConfig_default_instance_;
class XConfigList;
class XConfigListDefaultTypeInternal;
extern XConfigListDefaultTypeInternal _XConfigList_default_instance_;
class XDirConfig;
class XDirConfigDefaultTypeInternal;
extern XDirConfigDefaultTypeInternal _XDirConfig_default_instance_;
class XDirReq;
class XDirReqDefaultTypeInternal;
extern XDirReqDefaultTypeInternal _XDirReq_default_instance_;
class XDirRes;
class XDirResDefaultTypeInternal;
extern XDirResDefaultTypeInternal _XDirRes_default_instance_;
class XDirRes_XDir;
class XDirRes_XDirDefaultTypeInternal;
extern XDirRes_XDirDefaultTypeInternal _XDirRes_XDir_default_instance_;
class XGatewayConfig;
class XGatewayConfigDefaultTypeInternal;
extern XGatewayConfigDefaultTypeInternal _XGatewayConfig_default_instance_;
class XGetServiceReq;
class XGetServiceReqDefaultTypeInternal;
extern XGetServiceReqDefaultTypeInternal _XGetServiceReq_default_instance_;
class XLoadAllConfigReq;
class XLoadAllConfigReqDefaultTypeInternal;
extern XLoadAllConfigReqDefaultTypeInternal _XLoadAllConfigReq_default_instance_;
class XLoadConfigReq;
class XLoadConfigReqDefaultTypeInternal;
extern XLoadConfigReqDefaultTypeInternal _XLoadConfigReq_default_instance_;
class XLoginReq;
class XLoginReqDefaultTypeInternal;
extern XLoginReqDefaultTypeInternal _XLoginReq_default_instance_;
class XLoginRes;
class XLoginResDefaultTypeInternal;
extern XLoginResDefaultTypeInternal _XLoginRes_default_instance_;
class XMessageRes;
class XMessageResDefaultTypeInternal;
extern XMessageResDefaultTypeInternal _XMessageRes_default_instance_;
class XMsgHead;
class XMsgHeadDefaultTypeInternal;
extern XMsgHeadDefaultTypeInternal _XMsgHead_default_instance_;
class XMsgHeart;
class XMsgHeartDefaultTypeInternal;
extern XMsgHeartDefaultTypeInternal _XMsgHeart_default_instance_;
class XServiceInfo;
class XServiceInfoDefaultTypeInternal;
extern XServiceInfoDefaultTypeInternal _XServiceInfo_default_instance_;
class XServiceList;
class XServiceListDefaultTypeInternal;
extern XServiceListDefaultTypeInternal _XServiceList_default_instance_;
class XServiceMap;
class XServiceMapDefaultTypeInternal;
extern XServiceMapDefaultTypeInternal _XServiceMap_default_instance_;
class XServiceMap_ServiceMapEntry_DoNotUse;
class XServiceMap_ServiceMapEntry_DoNotUseDefaultTypeInternal;
extern XServiceMap_ServiceMapEntry_DoNotUseDefaultTypeInternal _XServiceMap_ServiceMapEntry_DoNotUse_default_instance_;
}  // namespace xmsg
PROTOBUF_NAMESPACE_OPEN
template<> ::xmsg::XAddLogReq* Arena::CreateMaybeMessage<::xmsg::XAddLogReq>(Arena*);
template<> ::xmsg::XAddUserReq* Arena::CreateMaybeMessage<::xmsg::XAddUserReq>(Arena*);
template<> ::xmsg::XAuthConfig* Arena::CreateMaybeMessage<::xmsg::XAuthConfig>(Arena*);
template<> ::xmsg::XChangePasswordReq* Arena::CreateMaybeMessage<::xmsg::XChangePasswordReq>(Arena*);
template<> ::xmsg::XConfig* Arena::CreateMaybeMessage<::xmsg::XConfig>(Arena*);
template<> ::xmsg::XConfigList* Arena::CreateMaybeMessage<::xmsg::XConfigList>(Arena*);
template<> ::xmsg::XDirConfig* Arena::CreateMaybeMessage<::xmsg::XDirConfig>(Arena*);
template<> ::xmsg::XDirReq* Arena::CreateMaybeMessage<::xmsg::XDirReq>(Arena*);
template<> ::xmsg::XDirRes* Arena::CreateMaybeMessage<::xmsg::XDirRes>(Arena*);
template<> ::xmsg::XDirRes_XDir* Arena::CreateMaybeMessage<::xmsg::XDirRes_XDir>(Arena*);
template<> ::xmsg::XGatewayConfig* Arena::CreateMaybeMessage<::xmsg::XGatewayConfig>(Arena*);
template<> ::xmsg::XGetServiceReq* Arena::CreateMaybeMessage<::xmsg::XGetServiceReq>(Arena*);
template<> ::xmsg::XLoadAllConfigReq* Arena::CreateMaybeMessage<::xmsg::XLoadAllConfigReq>(Arena*);
template<> ::xmsg::XLoadConfigReq* Arena::CreateMaybeMessage<::xmsg::XLoadConfigReq>(Arena*);
template<> ::xmsg::XLoginReq* Arena::CreateMaybeMessage<::xmsg::XLoginReq>(Arena*);
template<> ::xmsg::XLoginRes* Arena::CreateMaybeMessage<::xmsg::XLoginRes>(Arena*);
template<> ::xmsg::XMessageRes* Arena::CreateMaybeMessage<::xmsg::XMessageRes>(Arena*);
template<> ::xmsg::XMsgHead* Arena::CreateMaybeMessage<::xmsg::XMsgHead>(Arena*);
template<> ::xmsg::XMsgHeart* Arena::CreateMaybeMessage<::xmsg::XMsgHeart>(Arena*);
template<> ::xmsg::XServiceInfo* Arena::CreateMaybeMessage<::xmsg::XServiceInfo>(Arena*);
template<> ::xmsg::XServiceList* Arena::CreateMaybeMessage<::xmsg::XServiceList>(Arena*);
template<> ::xmsg::XServiceMap* Arena::CreateMaybeMessage<::xmsg::XServiceMap>(Arena*);
template<> ::xmsg::XServiceMap_ServiceMapEntry_DoNotUse* Arena::CreateMaybeMessage<::xmsg::XServiceMap_ServiceMapEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xmsg {

enum XMessageRes_XReturn : int {
  XMessageRes_XReturn_NONE = 0,
  XMessageRes_XReturn_OK = 1,
  XMessageRes_XReturn_ERROR = 2,
  XMessageRes_XReturn_XMessageRes_XReturn_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  XMessageRes_XReturn_XMessageRes_XReturn_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool XMessageRes_XReturn_IsValid(int value);
constexpr XMessageRes_XReturn XMessageRes_XReturn_XReturn_MIN = XMessageRes_XReturn_NONE;
constexpr XMessageRes_XReturn XMessageRes_XReturn_XReturn_MAX = XMessageRes_XReturn_ERROR;
constexpr int XMessageRes_XReturn_XReturn_ARRAYSIZE = XMessageRes_XReturn_XReturn_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* XMessageRes_XReturn_descriptor();
template<typename T>
inline const std::string& XMessageRes_XReturn_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XMessageRes_XReturn>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XMessageRes_XReturn_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    XMessageRes_XReturn_descriptor(), enum_t_value);
}
inline bool XMessageRes_XReturn_Parse(
    const std::string& name, XMessageRes_XReturn* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<XMessageRes_XReturn>(
    XMessageRes_XReturn_descriptor(), name, value);
}
enum XLoginRes_XLoginResType : int {
  XLoginRes_XLoginResType_NONE = 0,
  XLoginRes_XLoginResType_LOGGING = 1,
  XLoginRes_XLoginResType_OK = 2,
  XLoginRes_XLoginResType_ERROR = 3,
  XLoginRes_XLoginResType_NOUSER = 4,
  XLoginRes_XLoginResType_SERVER_ERROR = 5,
  XLoginRes_XLoginResType_XLoginRes_XLoginResType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  XLoginRes_XLoginResType_XLoginRes_XLoginResType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool XLoginRes_XLoginResType_IsValid(int value);
constexpr XLoginRes_XLoginResType XLoginRes_XLoginResType_XLoginResType_MIN = XLoginRes_XLoginResType_NONE;
constexpr XLoginRes_XLoginResType XLoginRes_XLoginResType_XLoginResType_MAX = XLoginRes_XLoginResType_SERVER_ERROR;
constexpr int XLoginRes_XLoginResType_XLoginResType_ARRAYSIZE = XLoginRes_XLoginResType_XLoginResType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* XLoginRes_XLoginResType_descriptor();
template<typename T>
inline const std::string& XLoginRes_XLoginResType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XLoginRes_XLoginResType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XLoginRes_XLoginResType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    XLoginRes_XLoginResType_descriptor(), enum_t_value);
}
inline bool XLoginRes_XLoginResType_Parse(
    const std::string& name, XLoginRes_XLoginResType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<XLoginRes_XLoginResType>(
    XLoginRes_XLoginResType_descriptor(), name, value);
}
enum XDirRes_XDirType : int {
  XDirRes_XDirType_OK = 0,
  XDirRes_XDirType_ERROR = 1,
  XDirRes_XDirType_NODIR = 2,
  XDirRes_XDirType_XDirRes_XDirType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  XDirRes_XDirType_XDirRes_XDirType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool XDirRes_XDirType_IsValid(int value);
constexpr XDirRes_XDirType XDirRes_XDirType_XDirType_MIN = XDirRes_XDirType_OK;
constexpr XDirRes_XDirType XDirRes_XDirType_XDirType_MAX = XDirRes_XDirType_NODIR;
constexpr int XDirRes_XDirType_XDirType_ARRAYSIZE = XDirRes_XDirType_XDirType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* XDirRes_XDirType_descriptor();
template<typename T>
inline const std::string& XDirRes_XDirType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XDirRes_XDirType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XDirRes_XDirType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    XDirRes_XDirType_descriptor(), enum_t_value);
}
inline bool XDirRes_XDirType_Parse(
    const std::string& name, XDirRes_XDirType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<XDirRes_XDirType>(
    XDirRes_XDirType_descriptor(), name, value);
}
enum XServiceType : int {
  ONE = 0,
  ALL = 1,
  XServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  XServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool XServiceType_IsValid(int value);
constexpr XServiceType XServiceType_MIN = ONE;
constexpr XServiceType XServiceType_MAX = ALL;
constexpr int XServiceType_ARRAYSIZE = XServiceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* XServiceType_descriptor();
template<typename T>
inline const std::string& XServiceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XServiceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XServiceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    XServiceType_descriptor(), enum_t_value);
}
inline bool XServiceType_Parse(
    const std::string& name, XServiceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<XServiceType>(
    XServiceType_descriptor(), name, value);
}
enum XLogLevel : int {
  XLOG_DEBUG = 0,
  XLOG_INFO = 1,
  XLOG_ERROR = 2,
  XLOG_FATAL = 3,
  XLogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  XLogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool XLogLevel_IsValid(int value);
constexpr XLogLevel XLogLevel_MIN = XLOG_DEBUG;
constexpr XLogLevel XLogLevel_MAX = XLOG_FATAL;
constexpr int XLogLevel_ARRAYSIZE = XLogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* XLogLevel_descriptor();
template<typename T>
inline const std::string& XLogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XLogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XLogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    XLogLevel_descriptor(), enum_t_value);
}
inline bool XLogLevel_Parse(
    const std::string& name, XLogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<XLogLevel>(
    XLogLevel_descriptor(), name, value);
}
// ===================================================================

class XMsgHead :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XMsgHead) */ {
 public:
  XMsgHead();
  virtual ~XMsgHead();

  XMsgHead(const XMsgHead& from);
  XMsgHead(XMsgHead&& from) noexcept
    : XMsgHead() {
    *this = ::std::move(from);
  }

  inline XMsgHead& operator=(const XMsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline XMsgHead& operator=(XMsgHead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XMsgHead& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XMsgHead* internal_default_instance() {
    return reinterpret_cast<const XMsgHead*>(
               &_XMsgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(XMsgHead* other);
  friend void swap(XMsgHead& a, XMsgHead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XMsgHead* New() const final {
    return CreateMaybeMessage<XMsgHead>(nullptr);
  }

  XMsgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XMsgHead>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XMsgHead& from);
  void MergeFrom(const XMsgHead& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XMsgHead* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XMsgHead";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // string service_name = 4;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 4;
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // string username = 6;
  void clear_username();
  static const int kUsernameFieldNumber = 6;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string rolename = 7;
  void clear_rolename();
  static const int kRolenameFieldNumber = 7;
  const std::string& rolename() const;
  void set_rolename(const std::string& value);
  void set_rolename(std::string&& value);
  void set_rolename(const char* value);
  void set_rolename(const char* value, size_t size);
  std::string* mutable_rolename();
  std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);

  // bytes md5 = 8;
  void clear_md5();
  static const int kMd5FieldNumber = 8;
  const std::string& md5() const;
  void set_md5(const std::string& value);
  void set_md5(std::string&& value);
  void set_md5(const char* value);
  void set_md5(const void* value, size_t size);
  std::string* mutable_md5();
  std::string* release_md5();
  void set_allocated_md5(std::string* md5);

  // int32 msg_size = 1;
  void clear_msg_size();
  static const int kMsgSizeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 msg_size() const;
  void set_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .xmsg.MsgType msg_type = 2;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 2;
  ::xmsg::MsgType msg_type() const;
  void set_msg_type(::xmsg::MsgType value);

  // int64 msg_id = 5;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int64 msg_id() const;
  void set_msg_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 offset = 9;
  void clear_offset();
  static const int kOffsetFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:xmsg.XMsgHead)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
  ::PROTOBUF_NAMESPACE_ID::int32 msg_size_;
  int msg_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 msg_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XMsgHeart :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XMsgHeart) */ {
 public:
  XMsgHeart();
  virtual ~XMsgHeart();

  XMsgHeart(const XMsgHeart& from);
  XMsgHeart(XMsgHeart&& from) noexcept
    : XMsgHeart() {
    *this = ::std::move(from);
  }

  inline XMsgHeart& operator=(const XMsgHeart& from) {
    CopyFrom(from);
    return *this;
  }
  inline XMsgHeart& operator=(XMsgHeart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XMsgHeart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XMsgHeart* internal_default_instance() {
    return reinterpret_cast<const XMsgHeart*>(
               &_XMsgHeart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(XMsgHeart* other);
  friend void swap(XMsgHeart& a, XMsgHeart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XMsgHeart* New() const final {
    return CreateMaybeMessage<XMsgHeart>(nullptr);
  }

  XMsgHeart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XMsgHeart>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XMsgHeart& from);
  void MergeFrom(const XMsgHeart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XMsgHeart* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XMsgHeart";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 count = 1;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:xmsg.XMsgHeart)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XMessageRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XMessageRes) */ {
 public:
  XMessageRes();
  virtual ~XMessageRes();

  XMessageRes(const XMessageRes& from);
  XMessageRes(XMessageRes&& from) noexcept
    : XMessageRes() {
    *this = ::std::move(from);
  }

  inline XMessageRes& operator=(const XMessageRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline XMessageRes& operator=(XMessageRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XMessageRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XMessageRes* internal_default_instance() {
    return reinterpret_cast<const XMessageRes*>(
               &_XMessageRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(XMessageRes* other);
  friend void swap(XMessageRes& a, XMessageRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XMessageRes* New() const final {
    return CreateMaybeMessage<XMessageRes>(nullptr);
  }

  XMessageRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XMessageRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XMessageRes& from);
  void MergeFrom(const XMessageRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XMessageRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XMessageRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef XMessageRes_XReturn XReturn;
  static constexpr XReturn NONE =
    XMessageRes_XReturn_NONE;
  static constexpr XReturn OK =
    XMessageRes_XReturn_OK;
  static constexpr XReturn ERROR =
    XMessageRes_XReturn_ERROR;
  static inline bool XReturn_IsValid(int value) {
    return XMessageRes_XReturn_IsValid(value);
  }
  static constexpr XReturn XReturn_MIN =
    XMessageRes_XReturn_XReturn_MIN;
  static constexpr XReturn XReturn_MAX =
    XMessageRes_XReturn_XReturn_MAX;
  static constexpr int XReturn_ARRAYSIZE =
    XMessageRes_XReturn_XReturn_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  XReturn_descriptor() {
    return XMessageRes_XReturn_descriptor();
  }
  template<typename T>
  static inline const std::string& XReturn_Name(T enum_t_value) {
    static_assert(::std::is_same<T, XReturn>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function XReturn_Name.");
    return XMessageRes_XReturn_Name(enum_t_value);
  }
  static inline bool XReturn_Parse(const std::string& name,
      XReturn* value) {
    return XMessageRes_XReturn_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes msg = 2;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);

  // .xmsg.XMessageRes.XReturn return = 1;
  void clear_return_();
  static const int kReturnFieldNumber = 1;
  ::xmsg::XMessageRes_XReturn return_() const;
  void set_return_(::xmsg::XMessageRes_XReturn value);

  // @@protoc_insertion_point(class_scope:xmsg.XMessageRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int return__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XAddUserReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XAddUserReq) */ {
 public:
  XAddUserReq();
  virtual ~XAddUserReq();

  XAddUserReq(const XAddUserReq& from);
  XAddUserReq(XAddUserReq&& from) noexcept
    : XAddUserReq() {
    *this = ::std::move(from);
  }

  inline XAddUserReq& operator=(const XAddUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XAddUserReq& operator=(XAddUserReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XAddUserReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XAddUserReq* internal_default_instance() {
    return reinterpret_cast<const XAddUserReq*>(
               &_XAddUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(XAddUserReq* other);
  friend void swap(XAddUserReq& a, XAddUserReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XAddUserReq* New() const final {
    return CreateMaybeMessage<XAddUserReq>(nullptr);
  }

  XAddUserReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XAddUserReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XAddUserReq& from);
  void MergeFrom(const XAddUserReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XAddUserReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XAddUserReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // string rolename = 3;
  void clear_rolename();
  static const int kRolenameFieldNumber = 3;
  const std::string& rolename() const;
  void set_rolename(const std::string& value);
  void set_rolename(std::string&& value);
  void set_rolename(const char* value);
  void set_rolename(const char* value, size_t size);
  std::string* mutable_rolename();
  std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);

  // @@protoc_insertion_point(class_scope:xmsg.XAddUserReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XChangePasswordReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XChangePasswordReq) */ {
 public:
  XChangePasswordReq();
  virtual ~XChangePasswordReq();

  XChangePasswordReq(const XChangePasswordReq& from);
  XChangePasswordReq(XChangePasswordReq&& from) noexcept
    : XChangePasswordReq() {
    *this = ::std::move(from);
  }

  inline XChangePasswordReq& operator=(const XChangePasswordReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XChangePasswordReq& operator=(XChangePasswordReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XChangePasswordReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XChangePasswordReq* internal_default_instance() {
    return reinterpret_cast<const XChangePasswordReq*>(
               &_XChangePasswordReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(XChangePasswordReq* other);
  friend void swap(XChangePasswordReq& a, XChangePasswordReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XChangePasswordReq* New() const final {
    return CreateMaybeMessage<XChangePasswordReq>(nullptr);
  }

  XChangePasswordReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XChangePasswordReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XChangePasswordReq& from);
  void MergeFrom(const XChangePasswordReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XChangePasswordReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XChangePasswordReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // string new_password = 3;
  void clear_new_password();
  static const int kNewPasswordFieldNumber = 3;
  const std::string& new_password() const;
  void set_new_password(const std::string& value);
  void set_new_password(std::string&& value);
  void set_new_password(const char* value);
  void set_new_password(const char* value, size_t size);
  std::string* mutable_new_password();
  std::string* release_new_password();
  void set_allocated_new_password(std::string* new_password);

  // @@protoc_insertion_point(class_scope:xmsg.XChangePasswordReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XLoginReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XLoginReq) */ {
 public:
  XLoginReq();
  virtual ~XLoginReq();

  XLoginReq(const XLoginReq& from);
  XLoginReq(XLoginReq&& from) noexcept
    : XLoginReq() {
    *this = ::std::move(from);
  }

  inline XLoginReq& operator=(const XLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XLoginReq& operator=(XLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLoginReq* internal_default_instance() {
    return reinterpret_cast<const XLoginReq*>(
               &_XLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(XLoginReq* other);
  friend void swap(XLoginReq& a, XLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLoginReq* New() const final {
    return CreateMaybeMessage<XLoginReq>(nullptr);
  }

  XLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XLoginReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XLoginReq& from);
  void MergeFrom(const XLoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XLoginReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // @@protoc_insertion_point(class_scope:xmsg.XLoginReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XLoginRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XLoginRes) */ {
 public:
  XLoginRes();
  virtual ~XLoginRes();

  XLoginRes(const XLoginRes& from);
  XLoginRes(XLoginRes&& from) noexcept
    : XLoginRes() {
    *this = ::std::move(from);
  }

  inline XLoginRes& operator=(const XLoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline XLoginRes& operator=(XLoginRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XLoginRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLoginRes* internal_default_instance() {
    return reinterpret_cast<const XLoginRes*>(
               &_XLoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(XLoginRes* other);
  friend void swap(XLoginRes& a, XLoginRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLoginRes* New() const final {
    return CreateMaybeMessage<XLoginRes>(nullptr);
  }

  XLoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XLoginRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XLoginRes& from);
  void MergeFrom(const XLoginRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLoginRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XLoginRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef XLoginRes_XLoginResType XLoginResType;
  static constexpr XLoginResType NONE =
    XLoginRes_XLoginResType_NONE;
  static constexpr XLoginResType LOGGING =
    XLoginRes_XLoginResType_LOGGING;
  static constexpr XLoginResType OK =
    XLoginRes_XLoginResType_OK;
  static constexpr XLoginResType ERROR =
    XLoginRes_XLoginResType_ERROR;
  static constexpr XLoginResType NOUSER =
    XLoginRes_XLoginResType_NOUSER;
  static constexpr XLoginResType SERVER_ERROR =
    XLoginRes_XLoginResType_SERVER_ERROR;
  static inline bool XLoginResType_IsValid(int value) {
    return XLoginRes_XLoginResType_IsValid(value);
  }
  static constexpr XLoginResType XLoginResType_MIN =
    XLoginRes_XLoginResType_XLoginResType_MIN;
  static constexpr XLoginResType XLoginResType_MAX =
    XLoginRes_XLoginResType_XLoginResType_MAX;
  static constexpr int XLoginResType_ARRAYSIZE =
    XLoginRes_XLoginResType_XLoginResType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  XLoginResType_descriptor() {
    return XLoginRes_XLoginResType_descriptor();
  }
  template<typename T>
  static inline const std::string& XLoginResType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, XLoginResType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function XLoginResType_Name.");
    return XLoginRes_XLoginResType_Name(enum_t_value);
  }
  static inline bool XLoginResType_Parse(const std::string& name,
      XLoginResType* value) {
    return XLoginRes_XLoginResType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // string rolename = 4;
  void clear_rolename();
  static const int kRolenameFieldNumber = 4;
  const std::string& rolename() const;
  void set_rolename(const std::string& value);
  void set_rolename(std::string&& value);
  void set_rolename(const char* value);
  void set_rolename(const char* value, size_t size);
  std::string* mutable_rolename();
  std::string* release_rolename();
  void set_allocated_rolename(std::string* rolename);

  // string username = 5;
  void clear_username();
  static const int kUsernameFieldNumber = 5;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // .xmsg.XLoginRes.XLoginResType res = 1;
  void clear_res();
  static const int kResFieldNumber = 1;
  ::xmsg::XLoginRes_XLoginResType res() const;
  void set_res(::xmsg::XLoginRes_XLoginResType value);

  // int32 expired_time = 3;
  void clear_expired_time();
  static const int kExpiredTimeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 expired_time() const;
  void set_expired_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:xmsg.XLoginRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rolename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  int res_;
  ::PROTOBUF_NAMESPACE_ID::int32 expired_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XDirReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XDirReq) */ {
 public:
  XDirReq();
  virtual ~XDirReq();

  XDirReq(const XDirReq& from);
  XDirReq(XDirReq&& from) noexcept
    : XDirReq() {
    *this = ::std::move(from);
  }

  inline XDirReq& operator=(const XDirReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XDirReq& operator=(XDirReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XDirReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XDirReq* internal_default_instance() {
    return reinterpret_cast<const XDirReq*>(
               &_XDirReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(XDirReq* other);
  friend void swap(XDirReq& a, XDirReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XDirReq* New() const final {
    return CreateMaybeMessage<XDirReq>(nullptr);
  }

  XDirReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XDirReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XDirReq& from);
  void MergeFrom(const XDirReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XDirReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XDirReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // @@protoc_insertion_point(class_scope:xmsg.XDirReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XDirRes_XDir :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XDirRes.XDir) */ {
 public:
  XDirRes_XDir();
  virtual ~XDirRes_XDir();

  XDirRes_XDir(const XDirRes_XDir& from);
  XDirRes_XDir(XDirRes_XDir&& from) noexcept
    : XDirRes_XDir() {
    *this = ::std::move(from);
  }

  inline XDirRes_XDir& operator=(const XDirRes_XDir& from) {
    CopyFrom(from);
    return *this;
  }
  inline XDirRes_XDir& operator=(XDirRes_XDir&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XDirRes_XDir& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XDirRes_XDir* internal_default_instance() {
    return reinterpret_cast<const XDirRes_XDir*>(
               &_XDirRes_XDir_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(XDirRes_XDir* other);
  friend void swap(XDirRes_XDir& a, XDirRes_XDir& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XDirRes_XDir* New() const final {
    return CreateMaybeMessage<XDirRes_XDir>(nullptr);
  }

  XDirRes_XDir* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XDirRes_XDir>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XDirRes_XDir& from);
  void MergeFrom(const XDirRes_XDir& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XDirRes_XDir* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XDirRes.XDir";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);

  // int32 filesize = 2;
  void clear_filesize();
  static const int kFilesizeFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 filesize() const;
  void set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:xmsg.XDirRes.XDir)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::int32 filesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XDirRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XDirRes) */ {
 public:
  XDirRes();
  virtual ~XDirRes();

  XDirRes(const XDirRes& from);
  XDirRes(XDirRes&& from) noexcept
    : XDirRes() {
    *this = ::std::move(from);
  }

  inline XDirRes& operator=(const XDirRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline XDirRes& operator=(XDirRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XDirRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XDirRes* internal_default_instance() {
    return reinterpret_cast<const XDirRes*>(
               &_XDirRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(XDirRes* other);
  friend void swap(XDirRes& a, XDirRes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XDirRes* New() const final {
    return CreateMaybeMessage<XDirRes>(nullptr);
  }

  XDirRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XDirRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XDirRes& from);
  void MergeFrom(const XDirRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XDirRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XDirRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef XDirRes_XDir XDir;

  typedef XDirRes_XDirType XDirType;
  static constexpr XDirType OK =
    XDirRes_XDirType_OK;
  static constexpr XDirType ERROR =
    XDirRes_XDirType_ERROR;
  static constexpr XDirType NODIR =
    XDirRes_XDirType_NODIR;
  static inline bool XDirType_IsValid(int value) {
    return XDirRes_XDirType_IsValid(value);
  }
  static constexpr XDirType XDirType_MIN =
    XDirRes_XDirType_XDirType_MIN;
  static constexpr XDirType XDirType_MAX =
    XDirRes_XDirType_XDirType_MAX;
  static constexpr int XDirType_ARRAYSIZE =
    XDirRes_XDirType_XDirType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  XDirType_descriptor() {
    return XDirRes_XDirType_descriptor();
  }
  template<typename T>
  static inline const std::string& XDirType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, XDirType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function XDirType_Name.");
    return XDirRes_XDirType_Name(enum_t_value);
  }
  static inline bool XDirType_Parse(const std::string& name,
      XDirType* value) {
    return XDirRes_XDirType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .xmsg.XDirRes.XDir dirs = 2;
  int dirs_size() const;
  void clear_dirs();
  static const int kDirsFieldNumber = 2;
  ::xmsg::XDirRes_XDir* mutable_dirs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XDirRes_XDir >*
      mutable_dirs();
  const ::xmsg::XDirRes_XDir& dirs(int index) const;
  ::xmsg::XDirRes_XDir* add_dirs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XDirRes_XDir >&
      dirs() const;

  // .xmsg.XDirRes.XDirType res = 1;
  void clear_res();
  static const int kResFieldNumber = 1;
  ::xmsg::XDirRes_XDirType res() const;
  void set_res(::xmsg::XDirRes_XDirType value);

  // @@protoc_insertion_point(class_scope:xmsg.XDirRes)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XDirRes_XDir > dirs_;
  int res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XServiceInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XServiceInfo) */ {
 public:
  XServiceInfo();
  virtual ~XServiceInfo();

  XServiceInfo(const XServiceInfo& from);
  XServiceInfo(XServiceInfo&& from) noexcept
    : XServiceInfo() {
    *this = ::std::move(from);
  }

  inline XServiceInfo& operator=(const XServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline XServiceInfo& operator=(XServiceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XServiceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XServiceInfo* internal_default_instance() {
    return reinterpret_cast<const XServiceInfo*>(
               &_XServiceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(XServiceInfo* other);
  friend void swap(XServiceInfo& a, XServiceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XServiceInfo* New() const final {
    return CreateMaybeMessage<XServiceInfo>(nullptr);
  }

  XServiceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XServiceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XServiceInfo& from);
  void MergeFrom(const XServiceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XServiceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XServiceInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string ip = 2;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);

  // int32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool is_find = 4;
  void clear_is_find();
  static const int kIsFindFieldNumber = 4;
  bool is_find() const;
  void set_is_find(bool value);

  // @@protoc_insertion_point(class_scope:xmsg.XServiceInfo)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  bool is_find_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XServiceList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XServiceList) */ {
 public:
  XServiceList();
  virtual ~XServiceList();

  XServiceList(const XServiceList& from);
  XServiceList(XServiceList&& from) noexcept
    : XServiceList() {
    *this = ::std::move(from);
  }

  inline XServiceList& operator=(const XServiceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline XServiceList& operator=(XServiceList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XServiceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XServiceList* internal_default_instance() {
    return reinterpret_cast<const XServiceList*>(
               &_XServiceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(XServiceList* other);
  friend void swap(XServiceList& a, XServiceList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XServiceList* New() const final {
    return CreateMaybeMessage<XServiceList>(nullptr);
  }

  XServiceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XServiceList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XServiceList& from);
  void MergeFrom(const XServiceList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XServiceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XServiceList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xmsg.XServiceInfo service = 1;
  int service_size() const;
  void clear_service();
  static const int kServiceFieldNumber = 1;
  ::xmsg::XServiceInfo* mutable_service(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XServiceInfo >*
      mutable_service();
  const ::xmsg::XServiceInfo& service(int index) const;
  ::xmsg::XServiceInfo* add_service();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XServiceInfo >&
      service() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:xmsg.XServiceList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XServiceInfo > service_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XServiceMap_ServiceMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<XServiceMap_ServiceMapEntry_DoNotUse, 
    std::string, ::xmsg::XServiceList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<XServiceMap_ServiceMapEntry_DoNotUse, 
    std::string, ::xmsg::XServiceList,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  XServiceMap_ServiceMapEntry_DoNotUse();
  XServiceMap_ServiceMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const XServiceMap_ServiceMapEntry_DoNotUse& other);
  static const XServiceMap_ServiceMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const XServiceMap_ServiceMapEntry_DoNotUse*>(&_XServiceMap_ServiceMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xmsg.XServiceMap.ServiceMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[12];
  }

  public:
};

// -------------------------------------------------------------------

class XServiceMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XServiceMap) */ {
 public:
  XServiceMap();
  virtual ~XServiceMap();

  XServiceMap(const XServiceMap& from);
  XServiceMap(XServiceMap&& from) noexcept
    : XServiceMap() {
    *this = ::std::move(from);
  }

  inline XServiceMap& operator=(const XServiceMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline XServiceMap& operator=(XServiceMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XServiceMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XServiceMap* internal_default_instance() {
    return reinterpret_cast<const XServiceMap*>(
               &_XServiceMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(XServiceMap* other);
  friend void swap(XServiceMap& a, XServiceMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XServiceMap* New() const final {
    return CreateMaybeMessage<XServiceMap>(nullptr);
  }

  XServiceMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XServiceMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XServiceMap& from);
  void MergeFrom(const XServiceMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XServiceMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XServiceMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .xmsg.XServiceList> service_map = 1;
  int service_map_size() const;
  void clear_service_map();
  static const int kServiceMapFieldNumber = 1;
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xmsg::XServiceList >&
      service_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xmsg::XServiceList >*
      mutable_service_map();

  // .xmsg.XMessageRes res = 2;
  bool has_res() const;
  void clear_res();
  static const int kResFieldNumber = 2;
  const ::xmsg::XMessageRes& res() const;
  ::xmsg::XMessageRes* release_res();
  ::xmsg::XMessageRes* mutable_res();
  void set_allocated_res(::xmsg::XMessageRes* res);

  // .xmsg.XServiceType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::xmsg::XServiceType type() const;
  void set_type(::xmsg::XServiceType value);

  // @@protoc_insertion_point(class_scope:xmsg.XServiceMap)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      XServiceMap_ServiceMapEntry_DoNotUse,
      std::string, ::xmsg::XServiceList,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > service_map_;
  ::xmsg::XMessageRes* res_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XGetServiceReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XGetServiceReq) */ {
 public:
  XGetServiceReq();
  virtual ~XGetServiceReq();

  XGetServiceReq(const XGetServiceReq& from);
  XGetServiceReq(XGetServiceReq&& from) noexcept
    : XGetServiceReq() {
    *this = ::std::move(from);
  }

  inline XGetServiceReq& operator=(const XGetServiceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XGetServiceReq& operator=(XGetServiceReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XGetServiceReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XGetServiceReq* internal_default_instance() {
    return reinterpret_cast<const XGetServiceReq*>(
               &_XGetServiceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(XGetServiceReq* other);
  friend void swap(XGetServiceReq& a, XGetServiceReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XGetServiceReq* New() const final {
    return CreateMaybeMessage<XGetServiceReq>(nullptr);
  }

  XGetServiceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XGetServiceReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XGetServiceReq& from);
  void MergeFrom(const XGetServiceReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XGetServiceReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XGetServiceReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .xmsg.XServiceType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::xmsg::XServiceType type() const;
  void set_type(::xmsg::XServiceType value);

  // @@protoc_insertion_point(class_scope:xmsg.XGetServiceReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XConfig) */ {
 public:
  XConfig();
  virtual ~XConfig();

  XConfig(const XConfig& from);
  XConfig(XConfig&& from) noexcept
    : XConfig() {
    *this = ::std::move(from);
  }

  inline XConfig& operator=(const XConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline XConfig& operator=(XConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XConfig* internal_default_instance() {
    return reinterpret_cast<const XConfig*>(
               &_XConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(XConfig* other);
  friend void swap(XConfig& a, XConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XConfig* New() const final {
    return CreateMaybeMessage<XConfig>(nullptr);
  }

  XConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XConfig& from);
  void MergeFrom(const XConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_name = 1;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // string service_ip = 3;
  void clear_service_ip();
  static const int kServiceIpFieldNumber = 3;
  const std::string& service_ip() const;
  void set_service_ip(const std::string& value);
  void set_service_ip(std::string&& value);
  void set_service_ip(const char* value);
  void set_service_ip(const char* value, size_t size);
  std::string* mutable_service_ip();
  std::string* release_service_ip();
  void set_allocated_service_ip(std::string* service_ip);

  // bytes private_pb = 4;
  void clear_private_pb();
  static const int kPrivatePbFieldNumber = 4;
  const std::string& private_pb() const;
  void set_private_pb(const std::string& value);
  void set_private_pb(std::string&& value);
  void set_private_pb(const char* value);
  void set_private_pb(const void* value, size_t size);
  std::string* mutable_private_pb();
  std::string* release_private_pb();
  void set_allocated_private_pb(std::string* private_pb);

  // bytes proto = 5;
  void clear_proto();
  static const int kProtoFieldNumber = 5;
  const std::string& proto() const;
  void set_proto(const std::string& value);
  void set_proto(std::string&& value);
  void set_proto(const char* value);
  void set_proto(const void* value, size_t size);
  std::string* mutable_proto();
  std::string* release_proto();
  void set_allocated_proto(std::string* proto);

  // int32 service_port = 2;
  void clear_service_port();
  static const int kServicePortFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port() const;
  void set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:xmsg.XConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_pb_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proto_;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XLoadConfigReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XLoadConfigReq) */ {
 public:
  XLoadConfigReq();
  virtual ~XLoadConfigReq();

  XLoadConfigReq(const XLoadConfigReq& from);
  XLoadConfigReq(XLoadConfigReq&& from) noexcept
    : XLoadConfigReq() {
    *this = ::std::move(from);
  }

  inline XLoadConfigReq& operator=(const XLoadConfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XLoadConfigReq& operator=(XLoadConfigReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XLoadConfigReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLoadConfigReq* internal_default_instance() {
    return reinterpret_cast<const XLoadConfigReq*>(
               &_XLoadConfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(XLoadConfigReq* other);
  friend void swap(XLoadConfigReq& a, XLoadConfigReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLoadConfigReq* New() const final {
    return CreateMaybeMessage<XLoadConfigReq>(nullptr);
  }

  XLoadConfigReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XLoadConfigReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XLoadConfigReq& from);
  void MergeFrom(const XLoadConfigReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLoadConfigReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XLoadConfigReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_ip = 2;
  void clear_service_ip();
  static const int kServiceIpFieldNumber = 2;
  const std::string& service_ip() const;
  void set_service_ip(const std::string& value);
  void set_service_ip(std::string&& value);
  void set_service_ip(const char* value);
  void set_service_ip(const char* value, size_t size);
  std::string* mutable_service_ip();
  std::string* release_service_ip();
  void set_allocated_service_ip(std::string* service_ip);

  // int32 service_port = 1;
  void clear_service_port();
  static const int kServicePortFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port() const;
  void set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:xmsg.XLoadConfigReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_ip_;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XDirConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XDirConfig) */ {
 public:
  XDirConfig();
  virtual ~XDirConfig();

  XDirConfig(const XDirConfig& from);
  XDirConfig(XDirConfig&& from) noexcept
    : XDirConfig() {
    *this = ::std::move(from);
  }

  inline XDirConfig& operator=(const XDirConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline XDirConfig& operator=(XDirConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XDirConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XDirConfig* internal_default_instance() {
    return reinterpret_cast<const XDirConfig*>(
               &_XDirConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(XDirConfig* other);
  friend void swap(XDirConfig& a, XDirConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XDirConfig* New() const final {
    return CreateMaybeMessage<XDirConfig>(nullptr);
  }

  XDirConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XDirConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XDirConfig& from);
  void MergeFrom(const XDirConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XDirConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XDirConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string root = 1;
  void clear_root();
  static const int kRootFieldNumber = 1;
  const std::string& root() const;
  void set_root(const std::string& value);
  void set_root(std::string&& value);
  void set_root(const char* value);
  void set_root(const char* value, size_t size);
  std::string* mutable_root();
  std::string* release_root();
  void set_allocated_root(std::string* root);

  // @@protoc_insertion_point(class_scope:xmsg.XDirConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XLoadAllConfigReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XLoadAllConfigReq) */ {
 public:
  XLoadAllConfigReq();
  virtual ~XLoadAllConfigReq();

  XLoadAllConfigReq(const XLoadAllConfigReq& from);
  XLoadAllConfigReq(XLoadAllConfigReq&& from) noexcept
    : XLoadAllConfigReq() {
    *this = ::std::move(from);
  }

  inline XLoadAllConfigReq& operator=(const XLoadAllConfigReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XLoadAllConfigReq& operator=(XLoadAllConfigReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XLoadAllConfigReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLoadAllConfigReq* internal_default_instance() {
    return reinterpret_cast<const XLoadAllConfigReq*>(
               &_XLoadAllConfigReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(XLoadAllConfigReq* other);
  friend void swap(XLoadAllConfigReq& a, XLoadAllConfigReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLoadAllConfigReq* New() const final {
    return CreateMaybeMessage<XLoadAllConfigReq>(nullptr);
  }

  XLoadAllConfigReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XLoadAllConfigReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XLoadAllConfigReq& from);
  void MergeFrom(const XLoadAllConfigReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLoadAllConfigReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XLoadAllConfigReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 page = 1;
  void clear_page();
  static const int kPageFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 page() const;
  void set_page(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 page_count = 2;
  void clear_page_count();
  static const int kPageCountFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 page_count() const;
  void set_page_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:xmsg.XLoadAllConfigReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 page_;
  ::PROTOBUF_NAMESPACE_ID::int32 page_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XConfigList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XConfigList) */ {
 public:
  XConfigList();
  virtual ~XConfigList();

  XConfigList(const XConfigList& from);
  XConfigList(XConfigList&& from) noexcept
    : XConfigList() {
    *this = ::std::move(from);
  }

  inline XConfigList& operator=(const XConfigList& from) {
    CopyFrom(from);
    return *this;
  }
  inline XConfigList& operator=(XConfigList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XConfigList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XConfigList* internal_default_instance() {
    return reinterpret_cast<const XConfigList*>(
               &_XConfigList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(XConfigList* other);
  friend void swap(XConfigList& a, XConfigList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XConfigList* New() const final {
    return CreateMaybeMessage<XConfigList>(nullptr);
  }

  XConfigList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XConfigList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XConfigList& from);
  void MergeFrom(const XConfigList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XConfigList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XConfigList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xmsg.XConfig config = 1;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  ::xmsg::XConfig* mutable_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XConfig >*
      mutable_config();
  const ::xmsg::XConfig& config(int index) const;
  ::xmsg::XConfig* add_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:xmsg.XConfigList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XConfig > config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XGatewayConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XGatewayConfig) */ {
 public:
  XGatewayConfig();
  virtual ~XGatewayConfig();

  XGatewayConfig(const XGatewayConfig& from);
  XGatewayConfig(XGatewayConfig&& from) noexcept
    : XGatewayConfig() {
    *this = ::std::move(from);
  }

  inline XGatewayConfig& operator=(const XGatewayConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline XGatewayConfig& operator=(XGatewayConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XGatewayConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XGatewayConfig* internal_default_instance() {
    return reinterpret_cast<const XGatewayConfig*>(
               &_XGatewayConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(XGatewayConfig* other);
  friend void swap(XGatewayConfig& a, XGatewayConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XGatewayConfig* New() const final {
    return CreateMaybeMessage<XGatewayConfig>(nullptr);
  }

  XGatewayConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XGatewayConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XGatewayConfig& from);
  void MergeFrom(const XGatewayConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XGatewayConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XGatewayConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string crt_path = 2;
  void clear_crt_path();
  static const int kCrtPathFieldNumber = 2;
  const std::string& crt_path() const;
  void set_crt_path(const std::string& value);
  void set_crt_path(std::string&& value);
  void set_crt_path(const char* value);
  void set_crt_path(const char* value, size_t size);
  std::string* mutable_crt_path();
  std::string* release_crt_path();
  void set_allocated_crt_path(std::string* crt_path);

  // string key_path = 3;
  void clear_key_path();
  static const int kKeyPathFieldNumber = 3;
  const std::string& key_path() const;
  void set_key_path(const std::string& value);
  void set_key_path(std::string&& value);
  void set_key_path(const char* value);
  void set_key_path(const char* value, size_t size);
  std::string* mutable_key_path();
  std::string* release_key_path();
  void set_allocated_key_path(std::string* key_path);

  // string ca_path = 4;
  void clear_ca_path();
  static const int kCaPathFieldNumber = 4;
  const std::string& ca_path() const;
  void set_ca_path(const std::string& value);
  void set_ca_path(std::string&& value);
  void set_ca_path(const char* value);
  void set_ca_path(const char* value, size_t size);
  std::string* mutable_ca_path();
  std::string* release_ca_path();
  void set_allocated_ca_path(std::string* ca_path);

  // bool is_ssl = 1;
  void clear_is_ssl();
  static const int kIsSslFieldNumber = 1;
  bool is_ssl() const;
  void set_is_ssl(bool value);

  // @@protoc_insertion_point(class_scope:xmsg.XGatewayConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crt_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ca_path_;
  bool is_ssl_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XAuthConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XAuthConfig) */ {
 public:
  XAuthConfig();
  virtual ~XAuthConfig();

  XAuthConfig(const XAuthConfig& from);
  XAuthConfig(XAuthConfig&& from) noexcept
    : XAuthConfig() {
    *this = ::std::move(from);
  }

  inline XAuthConfig& operator=(const XAuthConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline XAuthConfig& operator=(XAuthConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XAuthConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XAuthConfig* internal_default_instance() {
    return reinterpret_cast<const XAuthConfig*>(
               &_XAuthConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(XAuthConfig* other);
  friend void swap(XAuthConfig& a, XAuthConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XAuthConfig* New() const final {
    return CreateMaybeMessage<XAuthConfig>(nullptr);
  }

  XAuthConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XAuthConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XAuthConfig& from);
  void MergeFrom(const XAuthConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XAuthConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XAuthConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 token_timeout_sec = 1;
  void clear_token_timeout_sec();
  static const int kTokenTimeoutSecFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 token_timeout_sec() const;
  void set_token_timeout_sec(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:xmsg.XAuthConfig)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 token_timeout_sec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// -------------------------------------------------------------------

class XAddLogReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xmsg.XAddLogReq) */ {
 public:
  XAddLogReq();
  virtual ~XAddLogReq();

  XAddLogReq(const XAddLogReq& from);
  XAddLogReq(XAddLogReq&& from) noexcept
    : XAddLogReq() {
    *this = ::std::move(from);
  }

  inline XAddLogReq& operator=(const XAddLogReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline XAddLogReq& operator=(XAddLogReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const XAddLogReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XAddLogReq* internal_default_instance() {
    return reinterpret_cast<const XAddLogReq*>(
               &_XAddLogReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(XAddLogReq* other);
  friend void swap(XAddLogReq& a, XAddLogReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XAddLogReq* New() const final {
    return CreateMaybeMessage<XAddLogReq>(nullptr);
  }

  XAddLogReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<XAddLogReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const XAddLogReq& from);
  void MergeFrom(const XAddLogReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XAddLogReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xmsg.XAddLogReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_xmsg_5fcom_2eproto);
    return ::descriptor_table_xmsg_5fcom_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string service_ip = 1;
  void clear_service_ip();
  static const int kServiceIpFieldNumber = 1;
  const std::string& service_ip() const;
  void set_service_ip(const std::string& value);
  void set_service_ip(std::string&& value);
  void set_service_ip(const char* value);
  void set_service_ip(const char* value, size_t size);
  std::string* mutable_service_ip();
  std::string* release_service_ip();
  void set_allocated_service_ip(std::string* service_ip);

  // string service_name = 3;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 3;
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // bytes log_txt = 4;
  void clear_log_txt();
  static const int kLogTxtFieldNumber = 4;
  const std::string& log_txt() const;
  void set_log_txt(const std::string& value);
  void set_log_txt(std::string&& value);
  void set_log_txt(const char* value);
  void set_log_txt(const void* value, size_t size);
  std::string* mutable_log_txt();
  std::string* release_log_txt();
  void set_allocated_log_txt(std::string* log_txt);

  // string filename = 7;
  void clear_filename();
  static const int kFilenameFieldNumber = 7;
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);

  // int32 service_port = 2;
  void clear_service_port();
  static const int kServicePortFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port() const;
  void set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 log_time = 5;
  void clear_log_time();
  static const int kLogTimeFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 log_time() const;
  void set_log_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .xmsg.XLogLevel log_level = 6;
  void clear_log_level();
  static const int kLogLevelFieldNumber = 6;
  ::xmsg::XLogLevel log_level() const;
  void set_log_level(::xmsg::XLogLevel value);

  // int32 line = 9;
  void clear_line();
  static const int kLineFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::int32 line() const;
  void set_line(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:xmsg.XAddLogReq)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_txt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::int32 service_port_;
  ::PROTOBUF_NAMESPACE_ID::int32 log_time_;
  int log_level_;
  ::PROTOBUF_NAMESPACE_ID::int32 line_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_xmsg_5fcom_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// XMsgHead

// int32 msg_size = 1;
inline void XMsgHead::clear_msg_size() {
  msg_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XMsgHead::msg_size() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.msg_size)
  return msg_size_;
}
inline void XMsgHead::set_msg_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  msg_size_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.msg_size)
}

// .xmsg.MsgType msg_type = 2;
inline void XMsgHead::clear_msg_type() {
  msg_type_ = 0;
}
inline ::xmsg::MsgType XMsgHead::msg_type() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.msg_type)
  return static_cast< ::xmsg::MsgType >(msg_type_);
}
inline void XMsgHead::set_msg_type(::xmsg::MsgType value) {
  
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.msg_type)
}

// string token = 3;
inline void XMsgHead::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XMsgHead::token() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.token)
  return token_.GetNoArena();
}
inline void XMsgHead::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.token)
}
inline void XMsgHead::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XMsgHead.token)
}
inline void XMsgHead::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XMsgHead.token)
}
inline void XMsgHead::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XMsgHead.token)
}
inline std::string* XMsgHead::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XMsgHead.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XMsgHead::release_token() {
  // @@protoc_insertion_point(field_release:xmsg.XMsgHead.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XMsgHead::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XMsgHead.token)
}

// string service_name = 4;
inline void XMsgHead::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XMsgHead::service_name() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.service_name)
  return service_name_.GetNoArena();
}
inline void XMsgHead::set_service_name(const std::string& value) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.service_name)
}
inline void XMsgHead::set_service_name(std::string&& value) {
  
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XMsgHead.service_name)
}
inline void XMsgHead::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XMsgHead.service_name)
}
inline void XMsgHead::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XMsgHead.service_name)
}
inline std::string* XMsgHead::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XMsgHead.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XMsgHead::release_service_name() {
  // @@protoc_insertion_point(field_release:xmsg.XMsgHead.service_name)
  
  return service_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XMsgHead::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XMsgHead.service_name)
}

// int64 msg_id = 5;
inline void XMsgHead::clear_msg_id() {
  msg_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 XMsgHead::msg_id() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.msg_id)
  return msg_id_;
}
inline void XMsgHead::set_msg_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.msg_id)
}

// string username = 6;
inline void XMsgHead::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XMsgHead::username() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.username)
  return username_.GetNoArena();
}
inline void XMsgHead::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.username)
}
inline void XMsgHead::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XMsgHead.username)
}
inline void XMsgHead::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XMsgHead.username)
}
inline void XMsgHead::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XMsgHead.username)
}
inline std::string* XMsgHead::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XMsgHead.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XMsgHead::release_username() {
  // @@protoc_insertion_point(field_release:xmsg.XMsgHead.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XMsgHead::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XMsgHead.username)
}

// string rolename = 7;
inline void XMsgHead::clear_rolename() {
  rolename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XMsgHead::rolename() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.rolename)
  return rolename_.GetNoArena();
}
inline void XMsgHead::set_rolename(const std::string& value) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.rolename)
}
inline void XMsgHead::set_rolename(std::string&& value) {
  
  rolename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XMsgHead.rolename)
}
inline void XMsgHead::set_rolename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XMsgHead.rolename)
}
inline void XMsgHead::set_rolename(const char* value, size_t size) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XMsgHead.rolename)
}
inline std::string* XMsgHead::mutable_rolename() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XMsgHead.rolename)
  return rolename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XMsgHead::release_rolename() {
  // @@protoc_insertion_point(field_release:xmsg.XMsgHead.rolename)
  
  return rolename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XMsgHead::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XMsgHead.rolename)
}

// bytes md5 = 8;
inline void XMsgHead::clear_md5() {
  md5_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XMsgHead::md5() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.md5)
  return md5_.GetNoArena();
}
inline void XMsgHead::set_md5(const std::string& value) {
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.md5)
}
inline void XMsgHead::set_md5(std::string&& value) {
  
  md5_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XMsgHead.md5)
}
inline void XMsgHead::set_md5(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XMsgHead.md5)
}
inline void XMsgHead::set_md5(const void* value, size_t size) {
  
  md5_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XMsgHead.md5)
}
inline std::string* XMsgHead::mutable_md5() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XMsgHead.md5)
  return md5_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XMsgHead::release_md5() {
  // @@protoc_insertion_point(field_release:xmsg.XMsgHead.md5)
  
  return md5_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XMsgHead::set_allocated_md5(std::string* md5) {
  if (md5 != nullptr) {
    
  } else {
    
  }
  md5_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XMsgHead.md5)
}

// int64 offset = 9;
inline void XMsgHead::clear_offset() {
  offset_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 XMsgHead::offset() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHead.offset)
  return offset_;
}
inline void XMsgHead::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XMsgHead.offset)
}

// -------------------------------------------------------------------

// XMsgHeart

// int64 count = 1;
inline void XMsgHeart::clear_count() {
  count_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 XMsgHeart::count() const {
  // @@protoc_insertion_point(field_get:xmsg.XMsgHeart.count)
  return count_;
}
inline void XMsgHeart::set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XMsgHeart.count)
}

// -------------------------------------------------------------------

// XMessageRes

// .xmsg.XMessageRes.XReturn return = 1;
inline void XMessageRes::clear_return_() {
  return__ = 0;
}
inline ::xmsg::XMessageRes_XReturn XMessageRes::return_() const {
  // @@protoc_insertion_point(field_get:xmsg.XMessageRes.return)
  return static_cast< ::xmsg::XMessageRes_XReturn >(return__);
}
inline void XMessageRes::set_return_(::xmsg::XMessageRes_XReturn value) {
  
  return__ = value;
  // @@protoc_insertion_point(field_set:xmsg.XMessageRes.return)
}

// bytes msg = 2;
inline void XMessageRes::clear_msg() {
  msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XMessageRes::msg() const {
  // @@protoc_insertion_point(field_get:xmsg.XMessageRes.msg)
  return msg_.GetNoArena();
}
inline void XMessageRes::set_msg(const std::string& value) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XMessageRes.msg)
}
inline void XMessageRes::set_msg(std::string&& value) {
  
  msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XMessageRes.msg)
}
inline void XMessageRes::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XMessageRes.msg)
}
inline void XMessageRes::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XMessageRes.msg)
}
inline std::string* XMessageRes::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XMessageRes.msg)
  return msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XMessageRes::release_msg() {
  // @@protoc_insertion_point(field_release:xmsg.XMessageRes.msg)
  
  return msg_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XMessageRes::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XMessageRes.msg)
}

// -------------------------------------------------------------------

// XAddUserReq

// string username = 1;
inline void XAddUserReq::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XAddUserReq::username() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddUserReq.username)
  return username_.GetNoArena();
}
inline void XAddUserReq::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XAddUserReq.username)
}
inline void XAddUserReq::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XAddUserReq.username)
}
inline void XAddUserReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XAddUserReq.username)
}
inline void XAddUserReq::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XAddUserReq.username)
}
inline std::string* XAddUserReq::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XAddUserReq.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XAddUserReq::release_username() {
  // @@protoc_insertion_point(field_release:xmsg.XAddUserReq.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XAddUserReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XAddUserReq.username)
}

// string password = 2;
inline void XAddUserReq::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XAddUserReq::password() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddUserReq.password)
  return password_.GetNoArena();
}
inline void XAddUserReq::set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XAddUserReq.password)
}
inline void XAddUserReq::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XAddUserReq.password)
}
inline void XAddUserReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XAddUserReq.password)
}
inline void XAddUserReq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XAddUserReq.password)
}
inline std::string* XAddUserReq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XAddUserReq.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XAddUserReq::release_password() {
  // @@protoc_insertion_point(field_release:xmsg.XAddUserReq.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XAddUserReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XAddUserReq.password)
}

// string rolename = 3;
inline void XAddUserReq::clear_rolename() {
  rolename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XAddUserReq::rolename() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddUserReq.rolename)
  return rolename_.GetNoArena();
}
inline void XAddUserReq::set_rolename(const std::string& value) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XAddUserReq.rolename)
}
inline void XAddUserReq::set_rolename(std::string&& value) {
  
  rolename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XAddUserReq.rolename)
}
inline void XAddUserReq::set_rolename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XAddUserReq.rolename)
}
inline void XAddUserReq::set_rolename(const char* value, size_t size) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XAddUserReq.rolename)
}
inline std::string* XAddUserReq::mutable_rolename() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XAddUserReq.rolename)
  return rolename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XAddUserReq::release_rolename() {
  // @@protoc_insertion_point(field_release:xmsg.XAddUserReq.rolename)
  
  return rolename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XAddUserReq::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XAddUserReq.rolename)
}

// -------------------------------------------------------------------

// XChangePasswordReq

// string username = 1;
inline void XChangePasswordReq::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XChangePasswordReq::username() const {
  // @@protoc_insertion_point(field_get:xmsg.XChangePasswordReq.username)
  return username_.GetNoArena();
}
inline void XChangePasswordReq::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XChangePasswordReq.username)
}
inline void XChangePasswordReq::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XChangePasswordReq.username)
}
inline void XChangePasswordReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XChangePasswordReq.username)
}
inline void XChangePasswordReq::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XChangePasswordReq.username)
}
inline std::string* XChangePasswordReq::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XChangePasswordReq.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XChangePasswordReq::release_username() {
  // @@protoc_insertion_point(field_release:xmsg.XChangePasswordReq.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XChangePasswordReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XChangePasswordReq.username)
}

// string password = 2;
inline void XChangePasswordReq::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XChangePasswordReq::password() const {
  // @@protoc_insertion_point(field_get:xmsg.XChangePasswordReq.password)
  return password_.GetNoArena();
}
inline void XChangePasswordReq::set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XChangePasswordReq.password)
}
inline void XChangePasswordReq::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XChangePasswordReq.password)
}
inline void XChangePasswordReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XChangePasswordReq.password)
}
inline void XChangePasswordReq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XChangePasswordReq.password)
}
inline std::string* XChangePasswordReq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XChangePasswordReq.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XChangePasswordReq::release_password() {
  // @@protoc_insertion_point(field_release:xmsg.XChangePasswordReq.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XChangePasswordReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XChangePasswordReq.password)
}

// string new_password = 3;
inline void XChangePasswordReq::clear_new_password() {
  new_password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XChangePasswordReq::new_password() const {
  // @@protoc_insertion_point(field_get:xmsg.XChangePasswordReq.new_password)
  return new_password_.GetNoArena();
}
inline void XChangePasswordReq::set_new_password(const std::string& value) {
  
  new_password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XChangePasswordReq.new_password)
}
inline void XChangePasswordReq::set_new_password(std::string&& value) {
  
  new_password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XChangePasswordReq.new_password)
}
inline void XChangePasswordReq::set_new_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  new_password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XChangePasswordReq.new_password)
}
inline void XChangePasswordReq::set_new_password(const char* value, size_t size) {
  
  new_password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XChangePasswordReq.new_password)
}
inline std::string* XChangePasswordReq::mutable_new_password() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XChangePasswordReq.new_password)
  return new_password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XChangePasswordReq::release_new_password() {
  // @@protoc_insertion_point(field_release:xmsg.XChangePasswordReq.new_password)
  
  return new_password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XChangePasswordReq::set_allocated_new_password(std::string* new_password) {
  if (new_password != nullptr) {
    
  } else {
    
  }
  new_password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_password);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XChangePasswordReq.new_password)
}

// -------------------------------------------------------------------

// XLoginReq

// string username = 1;
inline void XLoginReq::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XLoginReq::username() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoginReq.username)
  return username_.GetNoArena();
}
inline void XLoginReq::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XLoginReq.username)
}
inline void XLoginReq::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XLoginReq.username)
}
inline void XLoginReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XLoginReq.username)
}
inline void XLoginReq::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XLoginReq.username)
}
inline std::string* XLoginReq::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XLoginReq.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XLoginReq::release_username() {
  // @@protoc_insertion_point(field_release:xmsg.XLoginReq.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XLoginReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginReq.username)
}

// string password = 2;
inline void XLoginReq::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XLoginReq::password() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoginReq.password)
  return password_.GetNoArena();
}
inline void XLoginReq::set_password(const std::string& value) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XLoginReq.password)
}
inline void XLoginReq::set_password(std::string&& value) {
  
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XLoginReq.password)
}
inline void XLoginReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XLoginReq.password)
}
inline void XLoginReq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XLoginReq.password)
}
inline std::string* XLoginReq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XLoginReq.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XLoginReq::release_password() {
  // @@protoc_insertion_point(field_release:xmsg.XLoginReq.password)
  
  return password_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XLoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginReq.password)
}

// -------------------------------------------------------------------

// XLoginRes

// .xmsg.XLoginRes.XLoginResType res = 1;
inline void XLoginRes::clear_res() {
  res_ = 0;
}
inline ::xmsg::XLoginRes_XLoginResType XLoginRes::res() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoginRes.res)
  return static_cast< ::xmsg::XLoginRes_XLoginResType >(res_);
}
inline void XLoginRes::set_res(::xmsg::XLoginRes_XLoginResType value) {
  
  res_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XLoginRes.res)
}

// string token = 2;
inline void XLoginRes::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XLoginRes::token() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoginRes.token)
  return token_.GetNoArena();
}
inline void XLoginRes::set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XLoginRes.token)
}
inline void XLoginRes::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XLoginRes.token)
}
inline void XLoginRes::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XLoginRes.token)
}
inline void XLoginRes::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XLoginRes.token)
}
inline std::string* XLoginRes::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XLoginRes.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XLoginRes::release_token() {
  // @@protoc_insertion_point(field_release:xmsg.XLoginRes.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XLoginRes::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginRes.token)
}

// int32 expired_time = 3;
inline void XLoginRes::clear_expired_time() {
  expired_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XLoginRes::expired_time() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoginRes.expired_time)
  return expired_time_;
}
inline void XLoginRes::set_expired_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  expired_time_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XLoginRes.expired_time)
}

// string rolename = 4;
inline void XLoginRes::clear_rolename() {
  rolename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XLoginRes::rolename() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoginRes.rolename)
  return rolename_.GetNoArena();
}
inline void XLoginRes::set_rolename(const std::string& value) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XLoginRes.rolename)
}
inline void XLoginRes::set_rolename(std::string&& value) {
  
  rolename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XLoginRes.rolename)
}
inline void XLoginRes::set_rolename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XLoginRes.rolename)
}
inline void XLoginRes::set_rolename(const char* value, size_t size) {
  
  rolename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XLoginRes.rolename)
}
inline std::string* XLoginRes::mutable_rolename() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XLoginRes.rolename)
  return rolename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XLoginRes::release_rolename() {
  // @@protoc_insertion_point(field_release:xmsg.XLoginRes.rolename)
  
  return rolename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XLoginRes::set_allocated_rolename(std::string* rolename) {
  if (rolename != nullptr) {
    
  } else {
    
  }
  rolename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rolename);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginRes.rolename)
}

// string username = 5;
inline void XLoginRes::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XLoginRes::username() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoginRes.username)
  return username_.GetNoArena();
}
inline void XLoginRes::set_username(const std::string& value) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XLoginRes.username)
}
inline void XLoginRes::set_username(std::string&& value) {
  
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XLoginRes.username)
}
inline void XLoginRes::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XLoginRes.username)
}
inline void XLoginRes::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XLoginRes.username)
}
inline std::string* XLoginRes::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XLoginRes.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XLoginRes::release_username() {
  // @@protoc_insertion_point(field_release:xmsg.XLoginRes.username)
  
  return username_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XLoginRes::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XLoginRes.username)
}

// -------------------------------------------------------------------

// XDirReq

// string path = 1;
inline void XDirReq::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XDirReq::path() const {
  // @@protoc_insertion_point(field_get:xmsg.XDirReq.path)
  return path_.GetNoArena();
}
inline void XDirReq::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XDirReq.path)
}
inline void XDirReq::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XDirReq.path)
}
inline void XDirReq::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XDirReq.path)
}
inline void XDirReq::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XDirReq.path)
}
inline std::string* XDirReq::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XDirReq.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XDirReq::release_path() {
  // @@protoc_insertion_point(field_release:xmsg.XDirReq.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XDirReq::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XDirReq.path)
}

// -------------------------------------------------------------------

// XDirRes_XDir

// string filename = 1;
inline void XDirRes_XDir::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XDirRes_XDir::filename() const {
  // @@protoc_insertion_point(field_get:xmsg.XDirRes.XDir.filename)
  return filename_.GetNoArena();
}
inline void XDirRes_XDir::set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XDirRes.XDir.filename)
}
inline void XDirRes_XDir::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XDirRes.XDir.filename)
}
inline void XDirRes_XDir::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XDirRes.XDir.filename)
}
inline void XDirRes_XDir::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XDirRes.XDir.filename)
}
inline std::string* XDirRes_XDir::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XDirRes.XDir.filename)
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XDirRes_XDir::release_filename() {
  // @@protoc_insertion_point(field_release:xmsg.XDirRes.XDir.filename)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XDirRes_XDir::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XDirRes.XDir.filename)
}

// int32 filesize = 2;
inline void XDirRes_XDir::clear_filesize() {
  filesize_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XDirRes_XDir::filesize() const {
  // @@protoc_insertion_point(field_get:xmsg.XDirRes.XDir.filesize)
  return filesize_;
}
inline void XDirRes_XDir::set_filesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  filesize_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XDirRes.XDir.filesize)
}

// -------------------------------------------------------------------

// XDirRes

// .xmsg.XDirRes.XDirType res = 1;
inline void XDirRes::clear_res() {
  res_ = 0;
}
inline ::xmsg::XDirRes_XDirType XDirRes::res() const {
  // @@protoc_insertion_point(field_get:xmsg.XDirRes.res)
  return static_cast< ::xmsg::XDirRes_XDirType >(res_);
}
inline void XDirRes::set_res(::xmsg::XDirRes_XDirType value) {
  
  res_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XDirRes.res)
}

// repeated .xmsg.XDirRes.XDir dirs = 2;
inline int XDirRes::dirs_size() const {
  return dirs_.size();
}
inline void XDirRes::clear_dirs() {
  dirs_.Clear();
}
inline ::xmsg::XDirRes_XDir* XDirRes::mutable_dirs(int index) {
  // @@protoc_insertion_point(field_mutable:xmsg.XDirRes.dirs)
  return dirs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XDirRes_XDir >*
XDirRes::mutable_dirs() {
  // @@protoc_insertion_point(field_mutable_list:xmsg.XDirRes.dirs)
  return &dirs_;
}
inline const ::xmsg::XDirRes_XDir& XDirRes::dirs(int index) const {
  // @@protoc_insertion_point(field_get:xmsg.XDirRes.dirs)
  return dirs_.Get(index);
}
inline ::xmsg::XDirRes_XDir* XDirRes::add_dirs() {
  // @@protoc_insertion_point(field_add:xmsg.XDirRes.dirs)
  return dirs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XDirRes_XDir >&
XDirRes::dirs() const {
  // @@protoc_insertion_point(field_list:xmsg.XDirRes.dirs)
  return dirs_;
}

// -------------------------------------------------------------------

// XServiceInfo

// string name = 1;
inline void XServiceInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XServiceInfo::name() const {
  // @@protoc_insertion_point(field_get:xmsg.XServiceInfo.name)
  return name_.GetNoArena();
}
inline void XServiceInfo::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XServiceInfo.name)
}
inline void XServiceInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XServiceInfo.name)
}
inline void XServiceInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XServiceInfo.name)
}
inline void XServiceInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XServiceInfo.name)
}
inline std::string* XServiceInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XServiceInfo.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XServiceInfo::release_name() {
  // @@protoc_insertion_point(field_release:xmsg.XServiceInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XServiceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XServiceInfo.name)
}

// string ip = 2;
inline void XServiceInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XServiceInfo::ip() const {
  // @@protoc_insertion_point(field_get:xmsg.XServiceInfo.ip)
  return ip_.GetNoArena();
}
inline void XServiceInfo::set_ip(const std::string& value) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XServiceInfo.ip)
}
inline void XServiceInfo::set_ip(std::string&& value) {
  
  ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XServiceInfo.ip)
}
inline void XServiceInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XServiceInfo.ip)
}
inline void XServiceInfo::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XServiceInfo.ip)
}
inline std::string* XServiceInfo::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XServiceInfo.ip)
  return ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XServiceInfo::release_ip() {
  // @@protoc_insertion_point(field_release:xmsg.XServiceInfo.ip)
  
  return ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XServiceInfo::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XServiceInfo.ip)
}

// int32 port = 3;
inline void XServiceInfo::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XServiceInfo::port() const {
  // @@protoc_insertion_point(field_get:xmsg.XServiceInfo.port)
  return port_;
}
inline void XServiceInfo::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XServiceInfo.port)
}

// bool is_find = 4;
inline void XServiceInfo::clear_is_find() {
  is_find_ = false;
}
inline bool XServiceInfo::is_find() const {
  // @@protoc_insertion_point(field_get:xmsg.XServiceInfo.is_find)
  return is_find_;
}
inline void XServiceInfo::set_is_find(bool value) {
  
  is_find_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XServiceInfo.is_find)
}

// -------------------------------------------------------------------

// XServiceList

// repeated .xmsg.XServiceInfo service = 1;
inline int XServiceList::service_size() const {
  return service_.size();
}
inline void XServiceList::clear_service() {
  service_.Clear();
}
inline ::xmsg::XServiceInfo* XServiceList::mutable_service(int index) {
  // @@protoc_insertion_point(field_mutable:xmsg.XServiceList.service)
  return service_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XServiceInfo >*
XServiceList::mutable_service() {
  // @@protoc_insertion_point(field_mutable_list:xmsg.XServiceList.service)
  return &service_;
}
inline const ::xmsg::XServiceInfo& XServiceList::service(int index) const {
  // @@protoc_insertion_point(field_get:xmsg.XServiceList.service)
  return service_.Get(index);
}
inline ::xmsg::XServiceInfo* XServiceList::add_service() {
  // @@protoc_insertion_point(field_add:xmsg.XServiceList.service)
  return service_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XServiceInfo >&
XServiceList::service() const {
  // @@protoc_insertion_point(field_list:xmsg.XServiceList.service)
  return service_;
}

// string name = 2;
inline void XServiceList::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XServiceList::name() const {
  // @@protoc_insertion_point(field_get:xmsg.XServiceList.name)
  return name_.GetNoArena();
}
inline void XServiceList::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XServiceList.name)
}
inline void XServiceList::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XServiceList.name)
}
inline void XServiceList::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XServiceList.name)
}
inline void XServiceList::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XServiceList.name)
}
inline std::string* XServiceList::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XServiceList.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XServiceList::release_name() {
  // @@protoc_insertion_point(field_release:xmsg.XServiceList.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XServiceList::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XServiceList.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// XServiceMap

// map<string, .xmsg.XServiceList> service_map = 1;
inline int XServiceMap::service_map_size() const {
  return service_map_.size();
}
inline void XServiceMap::clear_service_map() {
  service_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xmsg::XServiceList >&
XServiceMap::service_map() const {
  // @@protoc_insertion_point(field_map:xmsg.XServiceMap.service_map)
  return service_map_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xmsg::XServiceList >*
XServiceMap::mutable_service_map() {
  // @@protoc_insertion_point(field_mutable_map:xmsg.XServiceMap.service_map)
  return service_map_.MutableMap();
}

// .xmsg.XMessageRes res = 2;
inline bool XServiceMap::has_res() const {
  return this != internal_default_instance() && res_ != nullptr;
}
inline void XServiceMap::clear_res() {
  if (GetArenaNoVirtual() == nullptr && res_ != nullptr) {
    delete res_;
  }
  res_ = nullptr;
}
inline const ::xmsg::XMessageRes& XServiceMap::res() const {
  const ::xmsg::XMessageRes* p = res_;
  // @@protoc_insertion_point(field_get:xmsg.XServiceMap.res)
  return p != nullptr ? *p : *reinterpret_cast<const ::xmsg::XMessageRes*>(
      &::xmsg::_XMessageRes_default_instance_);
}
inline ::xmsg::XMessageRes* XServiceMap::release_res() {
  // @@protoc_insertion_point(field_release:xmsg.XServiceMap.res)
  
  ::xmsg::XMessageRes* temp = res_;
  res_ = nullptr;
  return temp;
}
inline ::xmsg::XMessageRes* XServiceMap::mutable_res() {
  
  if (res_ == nullptr) {
    auto* p = CreateMaybeMessage<::xmsg::XMessageRes>(GetArenaNoVirtual());
    res_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xmsg.XServiceMap.res)
  return res_;
}
inline void XServiceMap::set_allocated_res(::xmsg::XMessageRes* res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete res_;
  }
  if (res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, res, submessage_arena);
    }
    
  } else {
    
  }
  res_ = res;
  // @@protoc_insertion_point(field_set_allocated:xmsg.XServiceMap.res)
}

// .xmsg.XServiceType type = 3;
inline void XServiceMap::clear_type() {
  type_ = 0;
}
inline ::xmsg::XServiceType XServiceMap::type() const {
  // @@protoc_insertion_point(field_get:xmsg.XServiceMap.type)
  return static_cast< ::xmsg::XServiceType >(type_);
}
inline void XServiceMap::set_type(::xmsg::XServiceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XServiceMap.type)
}

// -------------------------------------------------------------------

// XGetServiceReq

// string name = 1;
inline void XGetServiceReq::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XGetServiceReq::name() const {
  // @@protoc_insertion_point(field_get:xmsg.XGetServiceReq.name)
  return name_.GetNoArena();
}
inline void XGetServiceReq::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XGetServiceReq.name)
}
inline void XGetServiceReq::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XGetServiceReq.name)
}
inline void XGetServiceReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XGetServiceReq.name)
}
inline void XGetServiceReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XGetServiceReq.name)
}
inline std::string* XGetServiceReq::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XGetServiceReq.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XGetServiceReq::release_name() {
  // @@protoc_insertion_point(field_release:xmsg.XGetServiceReq.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XGetServiceReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XGetServiceReq.name)
}

// .xmsg.XServiceType type = 2;
inline void XGetServiceReq::clear_type() {
  type_ = 0;
}
inline ::xmsg::XServiceType XGetServiceReq::type() const {
  // @@protoc_insertion_point(field_get:xmsg.XGetServiceReq.type)
  return static_cast< ::xmsg::XServiceType >(type_);
}
inline void XGetServiceReq::set_type(::xmsg::XServiceType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XGetServiceReq.type)
}

// -------------------------------------------------------------------

// XConfig

// string service_name = 1;
inline void XConfig::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XConfig::service_name() const {
  // @@protoc_insertion_point(field_get:xmsg.XConfig.service_name)
  return service_name_.GetNoArena();
}
inline void XConfig::set_service_name(const std::string& value) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XConfig.service_name)
}
inline void XConfig::set_service_name(std::string&& value) {
  
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XConfig.service_name)
}
inline void XConfig::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XConfig.service_name)
}
inline void XConfig::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XConfig.service_name)
}
inline std::string* XConfig::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XConfig.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XConfig::release_service_name() {
  // @@protoc_insertion_point(field_release:xmsg.XConfig.service_name)
  
  return service_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XConfig::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XConfig.service_name)
}

// int32 service_port = 2;
inline void XConfig::clear_service_port() {
  service_port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XConfig::service_port() const {
  // @@protoc_insertion_point(field_get:xmsg.XConfig.service_port)
  return service_port_;
}
inline void XConfig::set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  service_port_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XConfig.service_port)
}

// string service_ip = 3;
inline void XConfig::clear_service_ip() {
  service_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XConfig::service_ip() const {
  // @@protoc_insertion_point(field_get:xmsg.XConfig.service_ip)
  return service_ip_.GetNoArena();
}
inline void XConfig::set_service_ip(const std::string& value) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XConfig.service_ip)
}
inline void XConfig::set_service_ip(std::string&& value) {
  
  service_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XConfig.service_ip)
}
inline void XConfig::set_service_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XConfig.service_ip)
}
inline void XConfig::set_service_ip(const char* value, size_t size) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XConfig.service_ip)
}
inline std::string* XConfig::mutable_service_ip() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XConfig.service_ip)
  return service_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XConfig::release_service_ip() {
  // @@protoc_insertion_point(field_release:xmsg.XConfig.service_ip)
  
  return service_ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XConfig::set_allocated_service_ip(std::string* service_ip) {
  if (service_ip != nullptr) {
    
  } else {
    
  }
  service_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_ip);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XConfig.service_ip)
}

// bytes private_pb = 4;
inline void XConfig::clear_private_pb() {
  private_pb_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XConfig::private_pb() const {
  // @@protoc_insertion_point(field_get:xmsg.XConfig.private_pb)
  return private_pb_.GetNoArena();
}
inline void XConfig::set_private_pb(const std::string& value) {
  
  private_pb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XConfig.private_pb)
}
inline void XConfig::set_private_pb(std::string&& value) {
  
  private_pb_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XConfig.private_pb)
}
inline void XConfig::set_private_pb(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  private_pb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XConfig.private_pb)
}
inline void XConfig::set_private_pb(const void* value, size_t size) {
  
  private_pb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XConfig.private_pb)
}
inline std::string* XConfig::mutable_private_pb() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XConfig.private_pb)
  return private_pb_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XConfig::release_private_pb() {
  // @@protoc_insertion_point(field_release:xmsg.XConfig.private_pb)
  
  return private_pb_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XConfig::set_allocated_private_pb(std::string* private_pb) {
  if (private_pb != nullptr) {
    
  } else {
    
  }
  private_pb_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_pb);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XConfig.private_pb)
}

// bytes proto = 5;
inline void XConfig::clear_proto() {
  proto_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XConfig::proto() const {
  // @@protoc_insertion_point(field_get:xmsg.XConfig.proto)
  return proto_.GetNoArena();
}
inline void XConfig::set_proto(const std::string& value) {
  
  proto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XConfig.proto)
}
inline void XConfig::set_proto(std::string&& value) {
  
  proto_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XConfig.proto)
}
inline void XConfig::set_proto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XConfig.proto)
}
inline void XConfig::set_proto(const void* value, size_t size) {
  
  proto_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XConfig.proto)
}
inline std::string* XConfig::mutable_proto() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XConfig.proto)
  return proto_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XConfig::release_proto() {
  // @@protoc_insertion_point(field_release:xmsg.XConfig.proto)
  
  return proto_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XConfig::set_allocated_proto(std::string* proto) {
  if (proto != nullptr) {
    
  } else {
    
  }
  proto_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proto);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XConfig.proto)
}

// -------------------------------------------------------------------

// XLoadConfigReq

// int32 service_port = 1;
inline void XLoadConfigReq::clear_service_port() {
  service_port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XLoadConfigReq::service_port() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoadConfigReq.service_port)
  return service_port_;
}
inline void XLoadConfigReq::set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  service_port_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XLoadConfigReq.service_port)
}

// string service_ip = 2;
inline void XLoadConfigReq::clear_service_ip() {
  service_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XLoadConfigReq::service_ip() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoadConfigReq.service_ip)
  return service_ip_.GetNoArena();
}
inline void XLoadConfigReq::set_service_ip(const std::string& value) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XLoadConfigReq.service_ip)
}
inline void XLoadConfigReq::set_service_ip(std::string&& value) {
  
  service_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XLoadConfigReq.service_ip)
}
inline void XLoadConfigReq::set_service_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XLoadConfigReq.service_ip)
}
inline void XLoadConfigReq::set_service_ip(const char* value, size_t size) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XLoadConfigReq.service_ip)
}
inline std::string* XLoadConfigReq::mutable_service_ip() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XLoadConfigReq.service_ip)
  return service_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XLoadConfigReq::release_service_ip() {
  // @@protoc_insertion_point(field_release:xmsg.XLoadConfigReq.service_ip)
  
  return service_ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XLoadConfigReq::set_allocated_service_ip(std::string* service_ip) {
  if (service_ip != nullptr) {
    
  } else {
    
  }
  service_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_ip);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XLoadConfigReq.service_ip)
}

// -------------------------------------------------------------------

// XDirConfig

// string root = 1;
inline void XDirConfig::clear_root() {
  root_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XDirConfig::root() const {
  // @@protoc_insertion_point(field_get:xmsg.XDirConfig.root)
  return root_.GetNoArena();
}
inline void XDirConfig::set_root(const std::string& value) {
  
  root_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XDirConfig.root)
}
inline void XDirConfig::set_root(std::string&& value) {
  
  root_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XDirConfig.root)
}
inline void XDirConfig::set_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  root_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XDirConfig.root)
}
inline void XDirConfig::set_root(const char* value, size_t size) {
  
  root_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XDirConfig.root)
}
inline std::string* XDirConfig::mutable_root() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XDirConfig.root)
  return root_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XDirConfig::release_root() {
  // @@protoc_insertion_point(field_release:xmsg.XDirConfig.root)
  
  return root_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XDirConfig::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  root_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), root);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XDirConfig.root)
}

// -------------------------------------------------------------------

// XLoadAllConfigReq

// int32 page = 1;
inline void XLoadAllConfigReq::clear_page() {
  page_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XLoadAllConfigReq::page() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoadAllConfigReq.page)
  return page_;
}
inline void XLoadAllConfigReq::set_page(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  page_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XLoadAllConfigReq.page)
}

// int32 page_count = 2;
inline void XLoadAllConfigReq::clear_page_count() {
  page_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XLoadAllConfigReq::page_count() const {
  // @@protoc_insertion_point(field_get:xmsg.XLoadAllConfigReq.page_count)
  return page_count_;
}
inline void XLoadAllConfigReq::set_page_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  page_count_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XLoadAllConfigReq.page_count)
}

// -------------------------------------------------------------------

// XConfigList

// repeated .xmsg.XConfig config = 1;
inline int XConfigList::config_size() const {
  return config_.size();
}
inline void XConfigList::clear_config() {
  config_.Clear();
}
inline ::xmsg::XConfig* XConfigList::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:xmsg.XConfigList.config)
  return config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XConfig >*
XConfigList::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:xmsg.XConfigList.config)
  return &config_;
}
inline const ::xmsg::XConfig& XConfigList::config(int index) const {
  // @@protoc_insertion_point(field_get:xmsg.XConfigList.config)
  return config_.Get(index);
}
inline ::xmsg::XConfig* XConfigList::add_config() {
  // @@protoc_insertion_point(field_add:xmsg.XConfigList.config)
  return config_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xmsg::XConfig >&
XConfigList::config() const {
  // @@protoc_insertion_point(field_list:xmsg.XConfigList.config)
  return config_;
}

// -------------------------------------------------------------------

// XGatewayConfig

// bool is_ssl = 1;
inline void XGatewayConfig::clear_is_ssl() {
  is_ssl_ = false;
}
inline bool XGatewayConfig::is_ssl() const {
  // @@protoc_insertion_point(field_get:xmsg.XGatewayConfig.is_ssl)
  return is_ssl_;
}
inline void XGatewayConfig::set_is_ssl(bool value) {
  
  is_ssl_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XGatewayConfig.is_ssl)
}

// string crt_path = 2;
inline void XGatewayConfig::clear_crt_path() {
  crt_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XGatewayConfig::crt_path() const {
  // @@protoc_insertion_point(field_get:xmsg.XGatewayConfig.crt_path)
  return crt_path_.GetNoArena();
}
inline void XGatewayConfig::set_crt_path(const std::string& value) {
  
  crt_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XGatewayConfig.crt_path)
}
inline void XGatewayConfig::set_crt_path(std::string&& value) {
  
  crt_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XGatewayConfig.crt_path)
}
inline void XGatewayConfig::set_crt_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  crt_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XGatewayConfig.crt_path)
}
inline void XGatewayConfig::set_crt_path(const char* value, size_t size) {
  
  crt_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XGatewayConfig.crt_path)
}
inline std::string* XGatewayConfig::mutable_crt_path() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XGatewayConfig.crt_path)
  return crt_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XGatewayConfig::release_crt_path() {
  // @@protoc_insertion_point(field_release:xmsg.XGatewayConfig.crt_path)
  
  return crt_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XGatewayConfig::set_allocated_crt_path(std::string* crt_path) {
  if (crt_path != nullptr) {
    
  } else {
    
  }
  crt_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), crt_path);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XGatewayConfig.crt_path)
}

// string key_path = 3;
inline void XGatewayConfig::clear_key_path() {
  key_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XGatewayConfig::key_path() const {
  // @@protoc_insertion_point(field_get:xmsg.XGatewayConfig.key_path)
  return key_path_.GetNoArena();
}
inline void XGatewayConfig::set_key_path(const std::string& value) {
  
  key_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XGatewayConfig.key_path)
}
inline void XGatewayConfig::set_key_path(std::string&& value) {
  
  key_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XGatewayConfig.key_path)
}
inline void XGatewayConfig::set_key_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XGatewayConfig.key_path)
}
inline void XGatewayConfig::set_key_path(const char* value, size_t size) {
  
  key_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XGatewayConfig.key_path)
}
inline std::string* XGatewayConfig::mutable_key_path() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XGatewayConfig.key_path)
  return key_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XGatewayConfig::release_key_path() {
  // @@protoc_insertion_point(field_release:xmsg.XGatewayConfig.key_path)
  
  return key_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XGatewayConfig::set_allocated_key_path(std::string* key_path) {
  if (key_path != nullptr) {
    
  } else {
    
  }
  key_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_path);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XGatewayConfig.key_path)
}

// string ca_path = 4;
inline void XGatewayConfig::clear_ca_path() {
  ca_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XGatewayConfig::ca_path() const {
  // @@protoc_insertion_point(field_get:xmsg.XGatewayConfig.ca_path)
  return ca_path_.GetNoArena();
}
inline void XGatewayConfig::set_ca_path(const std::string& value) {
  
  ca_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XGatewayConfig.ca_path)
}
inline void XGatewayConfig::set_ca_path(std::string&& value) {
  
  ca_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XGatewayConfig.ca_path)
}
inline void XGatewayConfig::set_ca_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ca_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XGatewayConfig.ca_path)
}
inline void XGatewayConfig::set_ca_path(const char* value, size_t size) {
  
  ca_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XGatewayConfig.ca_path)
}
inline std::string* XGatewayConfig::mutable_ca_path() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XGatewayConfig.ca_path)
  return ca_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XGatewayConfig::release_ca_path() {
  // @@protoc_insertion_point(field_release:xmsg.XGatewayConfig.ca_path)
  
  return ca_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XGatewayConfig::set_allocated_ca_path(std::string* ca_path) {
  if (ca_path != nullptr) {
    
  } else {
    
  }
  ca_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ca_path);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XGatewayConfig.ca_path)
}

// -------------------------------------------------------------------

// XAuthConfig

// int32 token_timeout_sec = 1;
inline void XAuthConfig::clear_token_timeout_sec() {
  token_timeout_sec_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XAuthConfig::token_timeout_sec() const {
  // @@protoc_insertion_point(field_get:xmsg.XAuthConfig.token_timeout_sec)
  return token_timeout_sec_;
}
inline void XAuthConfig::set_token_timeout_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  token_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XAuthConfig.token_timeout_sec)
}

// -------------------------------------------------------------------

// XAddLogReq

// string service_ip = 1;
inline void XAddLogReq::clear_service_ip() {
  service_ip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XAddLogReq::service_ip() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.service_ip)
  return service_ip_.GetNoArena();
}
inline void XAddLogReq::set_service_ip(const std::string& value) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.service_ip)
}
inline void XAddLogReq::set_service_ip(std::string&& value) {
  
  service_ip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XAddLogReq.service_ip)
}
inline void XAddLogReq::set_service_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XAddLogReq.service_ip)
}
inline void XAddLogReq::set_service_ip(const char* value, size_t size) {
  
  service_ip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XAddLogReq.service_ip)
}
inline std::string* XAddLogReq::mutable_service_ip() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XAddLogReq.service_ip)
  return service_ip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XAddLogReq::release_service_ip() {
  // @@protoc_insertion_point(field_release:xmsg.XAddLogReq.service_ip)
  
  return service_ip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XAddLogReq::set_allocated_service_ip(std::string* service_ip) {
  if (service_ip != nullptr) {
    
  } else {
    
  }
  service_ip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_ip);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XAddLogReq.service_ip)
}

// int32 service_port = 2;
inline void XAddLogReq::clear_service_port() {
  service_port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XAddLogReq::service_port() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.service_port)
  return service_port_;
}
inline void XAddLogReq::set_service_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  service_port_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.service_port)
}

// string service_name = 3;
inline void XAddLogReq::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XAddLogReq::service_name() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.service_name)
  return service_name_.GetNoArena();
}
inline void XAddLogReq::set_service_name(const std::string& value) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.service_name)
}
inline void XAddLogReq::set_service_name(std::string&& value) {
  
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XAddLogReq.service_name)
}
inline void XAddLogReq::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XAddLogReq.service_name)
}
inline void XAddLogReq::set_service_name(const char* value, size_t size) {
  
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XAddLogReq.service_name)
}
inline std::string* XAddLogReq::mutable_service_name() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XAddLogReq.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XAddLogReq::release_service_name() {
  // @@protoc_insertion_point(field_release:xmsg.XAddLogReq.service_name)
  
  return service_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XAddLogReq::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XAddLogReq.service_name)
}

// bytes log_txt = 4;
inline void XAddLogReq::clear_log_txt() {
  log_txt_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XAddLogReq::log_txt() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.log_txt)
  return log_txt_.GetNoArena();
}
inline void XAddLogReq::set_log_txt(const std::string& value) {
  
  log_txt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.log_txt)
}
inline void XAddLogReq::set_log_txt(std::string&& value) {
  
  log_txt_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XAddLogReq.log_txt)
}
inline void XAddLogReq::set_log_txt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_txt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XAddLogReq.log_txt)
}
inline void XAddLogReq::set_log_txt(const void* value, size_t size) {
  
  log_txt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XAddLogReq.log_txt)
}
inline std::string* XAddLogReq::mutable_log_txt() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XAddLogReq.log_txt)
  return log_txt_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XAddLogReq::release_log_txt() {
  // @@protoc_insertion_point(field_release:xmsg.XAddLogReq.log_txt)
  
  return log_txt_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XAddLogReq::set_allocated_log_txt(std::string* log_txt) {
  if (log_txt != nullptr) {
    
  } else {
    
  }
  log_txt_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log_txt);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XAddLogReq.log_txt)
}

// int32 log_time = 5;
inline void XAddLogReq::clear_log_time() {
  log_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XAddLogReq::log_time() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.log_time)
  return log_time_;
}
inline void XAddLogReq::set_log_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  log_time_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.log_time)
}

// .xmsg.XLogLevel log_level = 6;
inline void XAddLogReq::clear_log_level() {
  log_level_ = 0;
}
inline ::xmsg::XLogLevel XAddLogReq::log_level() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.log_level)
  return static_cast< ::xmsg::XLogLevel >(log_level_);
}
inline void XAddLogReq::set_log_level(::xmsg::XLogLevel value) {
  
  log_level_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.log_level)
}

// string filename = 7;
inline void XAddLogReq::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& XAddLogReq::filename() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.filename)
  return filename_.GetNoArena();
}
inline void XAddLogReq::set_filename(const std::string& value) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.filename)
}
inline void XAddLogReq::set_filename(std::string&& value) {
  
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xmsg.XAddLogReq.filename)
}
inline void XAddLogReq::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xmsg.XAddLogReq.filename)
}
inline void XAddLogReq::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xmsg.XAddLogReq.filename)
}
inline std::string* XAddLogReq::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:xmsg.XAddLogReq.filename)
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* XAddLogReq::release_filename() {
  // @@protoc_insertion_point(field_release:xmsg.XAddLogReq.filename)
  
  return filename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void XAddLogReq::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:xmsg.XAddLogReq.filename)
}

// int32 line = 9;
inline void XAddLogReq::clear_line() {
  line_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 XAddLogReq::line() const {
  // @@protoc_insertion_point(field_get:xmsg.XAddLogReq.line)
  return line_;
}
inline void XAddLogReq::set_line(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  line_ = value;
  // @@protoc_insertion_point(field_set:xmsg.XAddLogReq.line)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace xmsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::xmsg::XMessageRes_XReturn> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xmsg::XMessageRes_XReturn>() {
  return ::xmsg::XMessageRes_XReturn_descriptor();
}
template <> struct is_proto_enum< ::xmsg::XLoginRes_XLoginResType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xmsg::XLoginRes_XLoginResType>() {
  return ::xmsg::XLoginRes_XLoginResType_descriptor();
}
template <> struct is_proto_enum< ::xmsg::XDirRes_XDirType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xmsg::XDirRes_XDirType>() {
  return ::xmsg::XDirRes_XDirType_descriptor();
}
template <> struct is_proto_enum< ::xmsg::XServiceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xmsg::XServiceType>() {
  return ::xmsg::XServiceType_descriptor();
}
template <> struct is_proto_enum< ::xmsg::XLogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xmsg::XLogLevel>() {
  return ::xmsg::XLogLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_xmsg_5fcom_2eproto
